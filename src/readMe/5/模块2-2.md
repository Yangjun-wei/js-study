###简单题
``````javascript
1.webpack内置识别esm、commonJS、amd、cmd等js模块的代码, 
它将js、css、图片、字体、html等一切资源都当做是模块。webpack
基本功能框架是把所有资源转成js函数输出，每个函数是一个模块。webpack
本身只具有把js文件转成js函数的功能， 如果需要加载图片、字体、样式、html等
其它资源， 那需要配置专用的loader。通过webpack配置文件entry配置一个或
多个入口开始解析目录和文件， 通过output指定把解析后生成的文件放到哪里。
loader除了加载资源的功能， 还可以将react或高版本js转成低版本js， 还可以用loader
对代码格式进行校验。另外有plugins用于对loader加载解析后生成的js函数做进一步的加工，
比如提取css为样式文件、根据模板html文件生成html文件并将css、js链接插入页面，对css、js、图片
等资源进行压缩、提取公共代码等。代码分割和压缩代码这部分功能webpack也允许配置在optimization选项中。
webpack配置文件既可导出为对象也可以是函数，如果是函数， 那么就很方便接收执行命令时的环境变量。
另外如果是在开发阶段，编译过程与生产打包基本没差别，只是我们可以手动通知webpack模式和loader、plugin是否起作用，
减去一些开发阶段不需要的过程。通过开发启动和打包启动执行的webpack命令不一样。server配置开发服务器，watch配置
如何观察文件变化。以开发命令启动webpack时，打包结果不生成文件、而是放在内存里。最后webpack打包生成的结果就是html、css、js
、静态资源。而js文件里一个对象， 这个对象放的是以函数形式存在的模块， 这个对象放在一个自执行函数里作为整个应用启动入口。
2.loader是翻译员， 能读懂特定类型的文件，翻译内容后以webpack要求的方式返回翻译后的结果。plugin是工程人员，在webpack
执行的特定阶段读取webpack执行过程中的具体信息选择性执行各种操作。plugin只需被定义为一个函数即可，当然loader即可调
node api， 也可以通过this调webpack提供的一些api。plugin可以定义为类或函数， 但类中或函数原型上必须定义一个apply方法，
这个方法接收两个参数:compiler和compilation。compiler是webpack执行时的实例对象， 包含webpack配置信息。compilation
包含webpack执行到这一特定阶段时webpack已经解析了的资源结果。公国complier.apply注册自己想在哪个时机执行自己的代码。
``````
###编程题
```javascript
webpack和webpack-cli一个提供模块解析功能、一个提供命令行工具。entry设置解析起始文件， output设置打包结果输出
路径。module中的rules配置各种类型的文件如何解析。如vue单文件、js文件、css、less、图片等。plugins配置模块被
webpack正确引入、被loader解析后还想做什么。通过htmlwebpackPlugin根据模板生成html文件，如果打包结果目录里存在
js和css文件，那么自动插入标签引用js和css文件。通过copyWebpackPlugin复制一些不是用import引用的静态资源。通过definePugin
给js、html等文件提供全局变量。通过miniCssExtractPlugin把css、less解析后的结果生成css文件。另外配了OptimizeCssAssetsPlugin和
uglifyJs分别对css和js文件进行压缩。eslint在js和vue文件被解析之前强制执行格式校验，不通过
则抛出错误终止打包。压缩和生成css文件、eslint校验是生产模式才配置的。开发模式不配置。开发模式需安装webpack-dev-server。启动
命令也不是webpack而是webpack-dev-server。配置文件里需要配置devServer项配置在哪个端口启动开发服务器、是否热更新、是否自动
打开浏览器等。因为项目的开发、生产配置分别在不同文件中，所以使用webpack-merge包合并基础webpack配置和开发、生产配置。另外配置了
一个esint校验命令， 指定校验的文件和修复格式错误。
```
